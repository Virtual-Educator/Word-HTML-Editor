"""
Streamlit application that cleans HTML pasted from Word documents.
"""

import re
from dataclasses import dataclass

import streamlit as st
from bs4 import BeautifulSoup, Comment


@dataclass
class CleanOptions:
    remove_inline_styles: bool = True
    remove_classes: bool = True
    remove_ids: bool = True
    remove_spans: bool = True
    remove_empty_tags: bool = True
    remove_comments: bool = True
    remove_office_tags: bool = True
    collapse_whitespace: bool = True


VOID_TAGS = {
    "area",
    "base",
    "br",
    "col",
    "embed",
    "hr",
    "img",
    "input",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr",
}

OFFICE_TAGS = {
    "o:p",
    "v:shapetype",
    "v:shape",
    "v:imagedata",
    "xml",
    "style",
}


def _remove_empty_tags(soup: BeautifulSoup) -> None:
    """Remove tags that have no meaningful text or children.

    The operation is repeated until no further changes are made so newly
    emptied parents are cleaned as well.
    """

    removed = True
    while removed:
        removed = False
        for tag in soup.find_all():
            if tag.name in VOID_TAGS:
                continue
            if tag.find(True):
                continue
            text = tag.get_text(strip=True)
            if text:
                continue
            tag.decompose()
            removed = True


def _remove_office_specific_content(soup: BeautifulSoup) -> None:
    """Strip Microsoft Office specific tags and attributes."""

    for office_tag in OFFICE_TAGS:
        for node in soup.find_all(office_tag):
            node.decompose()

    for tag in soup.find_all():
        for attribute in list(tag.attrs):
            if attribute.startswith("mso") or attribute.startswith("o:"):
                del tag.attrs[attribute]


def clean_html(raw_html: str, options: CleanOptions) -> str:
    """Clean HTML pasted from Word documents."""

    soup = BeautifulSoup(raw_html, "html.parser")

    if options.remove_comments:
        for comment in soup.find_all(string=lambda text: isinstance(text, Comment)):
            comment.extract()

    if options.remove_inline_styles:
        for tag in soup.find_all(style=True):
            del tag["style"]

    if options.remove_classes:
        for tag in soup.find_all(class_=True):
            del tag["class"]

    if options.remove_ids:
        for tag in soup.find_all(id=True):
            del tag["id"]

    if options.remove_spans:
        for span in soup.find_all("span"):
            span.unwrap()

    if options.remove_office_tags:
        _remove_office_specific_content(soup)

    if options.remove_empty_tags:
        _remove_empty_tags(soup)

    cleaned_html = soup.decode()

    if options.collapse_whitespace:
        cleaned_html = re.sub(r"\s+", " ", cleaned_html).strip()

    return cleaned_html


def render_sidebar() -> CleanOptions:
    st.sidebar.header("Cleaning options")
    remove_inline_styles = st.sidebar.checkbox(
        "Remove inline styles", value=True, help="Strip inline style attributes."
    )
    remove_classes = st.sidebar.checkbox(
        "Remove CSS classes", value=True, help="Strip class attributes."
    )
    remove_ids = st.sidebar.checkbox(
        "Remove element IDs", value=True, help="Strip id attributes."
    )
    remove_spans = st.sidebar.checkbox(
        "Unwrap span tags", value=True, help="Remove <span> tags while keeping content."
    )
    remove_empty_tags = st.sidebar.checkbox(
        "Remove empty tags", value=True, help="Delete tags with no visible content."
    )
    remove_comments = st.sidebar.checkbox(
        "Remove comments", value=True, help="Delete HTML comments from Word."
    )
    remove_office_tags = st.sidebar.checkbox(
        "Strip Office-specific markup",
        value=True,
        help="Remove tags and attributes generated by Microsoft Office.",
    )
    collapse_whitespace = st.sidebar.checkbox(
        "Collapse whitespace",
        value=True,
        help="Replace repeating spaces, tabs, and line breaks with a single space.",
    )

    return CleanOptions(
        remove_inline_styles=remove_inline_styles,
        remove_classes=remove_classes,
        remove_ids=remove_ids,
        remove_spans=remove_spans,
        remove_empty_tags=remove_empty_tags,
        remove_comments=remove_comments,
        remove_office_tags=remove_office_tags,
        collapse_whitespace=collapse_whitespace,
    )


def render_app():
    st.set_page_config(page_title="Word HTML Cleaner", layout="wide")
    st.title("Word âžœ HTML Cleaner")
    st.caption(
        "Paste content from Word or Google Docs, choose what to remove, and copy clean HTML."
    )

    options = render_sidebar()

    default_example = """<p class=\"MsoNormal\" style=\"margin-bottom:0in;margin-bottom:.0001pt;\">\n<span style=\"font-size:12.0pt;line-height:107%;\">Paste Word content here. <o:p></o:p></span></p>"""

    st.markdown(
        "Paste rich text (including Word formatting) into the left box. The cleaned HTML "
        "updates instantly in the right box as you type or toggle cleaning options."
    )

    left, right = st.columns(2)

    with left:
        st.subheader("Word content")
        raw_html = st.text_area(
            "Word or Google Docs input",
            value=default_example,
            height=350,
            placeholder="Paste formatted content or the HTML exported from Word...",
            help="Edit the pasted content here. Each change is reflected in the HTML panel.",
        )
        st.info(
            "Use the checkboxes in the sidebar to control how aggressively the cleaner removes "
            "inline styles, classes, IDs, comments, and other Office-specific markup."
        )

    cleaned_html = clean_html(raw_html, options) if raw_html else ""
    html_placeholder = "<p>Cleaned HTML will appear here as soon as you paste or type.</p>"
    display_html = cleaned_html or html_placeholder

    with right:
        st.subheader("HTML")
        st.caption("Live HTML output that mirrors the Word box.")
        st.text_area(
            "Clean HTML output",
            value=display_html,
            height=350,
            placeholder=display_html,
            help="This view refreshes automatically; copy it directly into your project.",
        )
        st.code(display_html, language="html")
        st.download_button(
            "Download cleaned HTML",
            data=cleaned_html,
            file_name="cleaned.html",
            mime="text/html",
            disabled=not cleaned_html,
        )

    st.divider()
    st.subheader("Preview")
    st.caption("Rendered version of the cleaned HTML.")
    st.components.v1.html(
        cleaned_html or "<p>Cleaned HTML preview will appear here.</p>", height=300
    )


if __name__ == "__main__":
    render_app()
